function dfs(arr, path, res) {
    console.log('arr:', arr, 'path:', path, 'res:' ,res);
    if (path.length === arr.length) { // 递归终止条件
        res.push([...path]); // 记录当前排列
        return;
    }
    for (let i = 0; i < arr.length; i++) { // 遍历所有元素
        if (path.includes(arr[i])) continue; // 剪枝，避免重复
        path.push(arr[i]); // 选择
        console.log('i:', i, 'path：', path)
        dfs(arr, path, res);
        console.log('i:', i, 'path11：', path)
        path.pop(); // 撤销选择，回溯
        console.log('i:', i, 'path22：', path)
    }
}
function quanpailie(arr) { 
    let path = [], res = [];
    dfs(arr, path, res);
    console.log(res);
}
quanpailie([1,2,3]);


// dfs([1,2,3], [], [])
//  ├─ 选择 1 → dfs([1,2,3], [1], [])
//  │   ├─ 选择 2 → dfs([1,2,3], [1,2], [])
//  │   │   ├─ 选择 3 → dfs([1,2,3], [1,2,3], []) ✅ 记录结果
//  │   │   ├─ 回溯：移除 3，回到 [1,2]
//  │   ├─ 选择 3 → dfs([1,2,3], [1,3], [])
//  │   │   ├─ 选择 2 → dfs([1,3,2], [1,3,2], []) ✅ 记录结果
//  │   │   ├─ 回溯：移除 2，回到 [1,3]
//  │   ├─ 回溯：移除 3，回到 [1]
//  ├─ 选择 2 → dfs([1,2,3], [2], [])
//  │   ├─ 选择 1 → dfs([1,2,3], [2,1], [])
//  │   │   ├─ 选择 3 → dfs([1,2,3], [2,1,3], []) ✅ 记录结果
//  │   │   ├─ 回溯：移除 3，回到 [2,1]
//  │   ├─ 选择 3 → dfs([1,2,3], [2,3], [])
//  │   │   ├─ 选择 1 → dfs([1,2,3], [2,3,1], []) ✅ 记录结果
//  │   │   ├─ 回溯：移除 1，回到 [2,3]
//  │   ├─ 回溯：移除 3，回到 [2]
//  ├─ 选择 3 → dfs([1,2,3], [3], [])
//  │   ├─ 选择 1 → dfs([1,2,3], [3,1], [])
//  │   │   ├─ 选择 2 → dfs([1,2,3], [3,1,2], []) ✅ 记录结果
//  │   │   ├─ 回溯：移除 2，回到 [3,1]
//  │   ├─ 选择 2 → dfs([1,2,3], [3,2], [])
//  │   │   ├─ 选择 1 → dfs([1,2,3], [3,2,1], []) ✅ 记录结果
//  │   │   ├─ 回溯：移除 1，回到 [3,2]
//  │   ├─ 回溯：移除 2，回到 [3]
//  ├─ 回溯：移除 3，回到 []